// Firebase core is required to initialize Firebase before use.
//
// Without this, Firebase services (Auth, Firestore, etc.)
// will throw runtime exceptions.
import 'package:firebase_core/firebase_core.dart';
// Contains platform-specific Firebase configuration
// (API keys, project ID, app ID, etc.).
//
// This is auto-generated by FlutterFire CLI and SHOULD NOT
// be manually edited.
import 'package:learningfirebase/firebase_options.dart';
// Application-level user abstraction.
//
// This ensures Firebase's User object NEVER leaves
// the authentication layer.
import 'package:learningfirebase/services/auth/auth_user.dart';
// Authentication contract (interface).
//
// FirebaseAuthProvider MUST implement this to be usable
// by AuthService.
import 'package:learningfirebase/services/auth/auth_provider.dart';
// Domain-specific authentication exceptions.
//
// These replace FirebaseAuthException so the UI
// never depends on Firebase error codes.
import 'package:learningfirebase/services/auth/auth_exceptions.dart';

/// Import only the required Firebase Auth classes.
///
///`show` is used to:
/// - Reduce namespace pollution
/// - Make dependencies explicit
import 'package:firebase_auth/firebase_auth.dart'
    show FirebaseAuth, FirebaseAuthException;

/// ---------------------------------------------------------------------------
/// FIREBASE AUTH PROVIDER
/// ---------------------------------------------------------------------------
///
/// This class is a **concrete implementation** of AuthProvider
/// using Firebase Authentication.
///
/// Architectural role:
/// - Adapter between Firebase SDK and application domain
/// - Translates Firebase users → AuthUser
/// - Translates Firebase errors → domain exceptions
///
/// UI NEVER imports this class directly.
///
class FirebaseAuthProvider implements AuthProvider {
  /// -------------------------------------------------------------------------
  /// CREATE USER
  /// -------------------------------------------------------------------------
  ///
  /// Registers a new user using email & password.
  ///
  /// Firebase behavior:
  /// - Automatically signs in the user after registration
  ///
  /// App behavior:
  /// - Returns an AuthUser (not Firebase User)
  /// - Throws domain-specific exceptions
  @override
  Future<AuthUser> createUser({
    required String email,
    required String password,
  }) async {
    try {
      // Ask Firebase to create a new user account.
      //
      // This performs validation and persistence
      // on Firebase’s servers.
      await FirebaseAuth.instance.createUserWithEmailAndPassword(
        email: email,
        password: password,
      );
      // Fetch the currently authenticated user.
      //
      // Firebase signs the user in automatically after creation.
      final user = currentUser;
      if (user != null) {
        // Return the domain-level user abstraction.
        return user;
      } else {
        // Defensive programming:
        // If Firebase fails silently, fail explicitly.
        throw UserNotLoggedInAuthException();
      }
    } on FirebaseAuthException catch (e) {
      // Map Firebase-specific error codes
      // to application-specific exceptions.
      //
      // This prevents Firebase details from leaking
      // into UI or business logic.
      if (e.code == "weak-password") {
        throw WeakPasswordAuthException();
      } else if (e.code == "email-already-in-use") {
        throw EmailAlreadyInUseAuthException();
      } else if (e.code == "invalid-email") {
        throw InvalidEmailAuthException();
      } else {
        throw GenericAuthException();
      }
    } catch (_) {
      // Catch-all for unexpected failures.
      //
      // Ensures app does not crash due to
      // unhandled backend issues.
      throw GenericAuthException();
    }
  }

  /// -------------------------------------------------------------------------
  /// CURRENT USER
  /// -------------------------------------------------------------------------
  ///
  /// Returns the currently authenticated user, if any.
  ///
  /// This method:
  /// - Reads FirebaseAuth state
  /// - Converts Firebase User → AuthUser
  /// - Returns null if no user is logged in
  ///
  @override
  AuthUser? get currentUser {
    final user = FirebaseAuth.instance.currentUser;
    if (user != null) {
      return AuthUser.fromFirebase(user);
    } else {
      return null;
    }
  }

  /// -------------------------------------------------------------------------
  /// LOG IN
  /// -------------------------------------------------------------------------
  ///
  /// Authenticates a user with email & password.
  ///
  /// Firebase handles:
  /// - Credential verification
  /// - Session persistence
  ///
  /// App handles:
  /// - Error translation
  /// - Domain user abstraction
  @override
  Future<AuthUser> logIn({
    required String email,
    required String password,
  }) async {
    try {
      // Ask Firebase to authenticate the user.
      await FirebaseAuth.instance.signInWithEmailAndPassword(
        email: email,
        password: password,
      );
      // Fetch authenticated user.
      final user = currentUser;
      if (user != null) {
        return user;
      } else {
        // Should not happen under normal circumstances.
        throw UserNotLoggedInAuthException();
      }
    } on FirebaseAuthException catch (e) {
      // Translate Firebase errors to domain errors.
      if (e.code == "user-not-found") {
        throw UserNotFoundAuthException();
      } else if (e.code == "wrong-password") {
        throw WrongPasswordAuthException();
      } else {
        throw GenericAuthException();
      }
    } catch (_) {
      throw GenericAuthException();
    }
  }

  /// -------------------------------------------------------------------------
  /// LOG OUT
  /// -------------------------------------------------------------------------
  ///
  /// Terminatess the current authentication session.
  ///
  /// Firebase clears:
  /// - Cached tokens
  /// - Local auth state
  @override
  Future<void> logOut() async {
    final user = FirebaseAuth.instance.currentUser;
    if (user != null) {
      // Explicitly sign out.
      await FirebaseAuth.instance.signOut();
    } else {
      // Prevents silent failures.
      throw UserNotLoggedInAuthException();
    }
  }

  /// -------------------------------------------------------------------------
  /// EMAIL VERIFICATION
  /// -------------------------------------------------------------------------
  ///
  /// Sends a verification email to the current user.
  ///
  /// Firebase handles:
  /// - Email delivery
  /// - Verification links
  ///
  /// App enforces:
  /// - User must be logged in
  @override
  Future<void> sendEmailVerification() async {
    final user = FirebaseAuth.instance.currentUser;
    if (user != null) {
      await user.sendEmailVerification();
    } else {
      throw UserNotLoggedInAuthException();
    }
  }

  /// -------------------------------------------------------------------------
  /// INITIALIZATION
  /// -------------------------------------------------------------------------
  ///
  /// Initializes Firebase before any auth operations.
  ///
  /// This MUST be called before:
  /// - login
  /// - registration
  /// - checking currentUser
  ///
  /// Typically called during app startup.
  @override
  Future<void> initialize() async {
    await Firebase.initializeApp(
      options: DefaultFirebaseOptions.currentPlatform,
    );
  }

  @override
  Future<void> sendPasswordResetEmail({required String toEmail}) async {
    try {
      await FirebaseAuth.instance.sendPasswordResetEmail(email: toEmail);
    } on FirebaseAuthException catch(e){
      switch(e.code){
        case 'firebase_auth/user-not-found':
          throw UserNotFoundAuthException();
        case 'firebase_auth/invalid-email':
          throw InvalidEmailAuthException();
        default:
          throw GenericAuthException();
      }
    }catch (_) {
      throw GenericAuthException();
    }
  }
}
